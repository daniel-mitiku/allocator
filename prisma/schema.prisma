// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL") // Your MongoDB connection string in the .env file
}

// ---------------------------------------------------
// ENUMS & TYPES - For defining fixed sets of values
// ---------------------------------------------------

enum Role {
  LECTURER
  LAB_ASSISTANT
  COORDINATOR
  ADVISOR
  ADMIN
  SPEAKER
}

enum SystemRole {
  SUPER_ADMIN // Can manage all colleges and see everything
  COLLEGE_ADMIN // Can manage only their assigned college resources
  PERSONNEL // Regular staff/faculty member
}

enum RoomType {
  LECTURE_HALL
  COMPUTER_LAB
  OFFICE
  MEETING_ROOM
  AUDITORIUM
}

enum AttendeeLevel {
  SECTION // Activity is for the entire section
  GROUP // Activity is for a sub-group of a section
}

enum ScheduleStatus {
  DRAFT // Initial setup phase
  PREFERENCES_OPEN // Personnel can log in and set preferences
  LOCKED // Preferences are closed, ready for allocation
  COMPLETED // Allocation is done and the schedule is published
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

// NEW ENUM for Spacing Preference
enum SpacingPreference {
  FAR_APART
  CLOSE_TOGETHER
  NONE
}

// Composite Type for embedding required personnel data directly into an ActivityTemplate
type RequiredPersonnel {
  role  Role
  count Int
}

// ADD THIS NEW COMPOSITE TYPE
type AvailabilityBlock {
  dayOfWeek DayOfWeek
  startTime String // "08:00"
  endTime   String // "17:00"
}

// --- ADD THIS NEW MODEL ---
model AvailabilityTemplate {
  id                 String              @id @default(auto()) @map("_id") @db.ObjectId
  name               String              @unique
  description        String?
  college            College             @relation(fields: [collegeId], references: [id])
  collegeId          String              @db.ObjectId
  availabilityBlocks AvailabilityBlock[]
  scheduleInstances  ScheduleInstance[]
}

type AssignmentRecord {
  personnelId        String
  courseId           String
  activityTemplateId String
  scheduleInstanceId String
  assignedAt         DateTime
  performance        String? // Optional performance notes
}

// ---------------------------------------------------
// COLLEGE ENTITY - New top-level organization
// ---------------------------------------------------

model College {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String  @unique // "College of Engineering"
  code        String  @unique // "COE"
  description String?
  isActive    Boolean @default(true)

  // College resources
  users                 User[]
  rooms                 Room[]
  courses               Course[]
  programs              Program[]
  scheduleInstances     ScheduleInstance[]
  availabilityTemplates AvailabilityTemplate[]

  // assigmentRecord AssignmentRecord[] // I don'

  // Historical records for this college
  assignmentHistory AssignmentHistory[] @relation("CollegeHistory")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ---------------------------------------------------
// CORE RESOURCES - The fundamental building blocks
// ---------------------------------------------------

model User {
  id              String @id @default(auto()) @map("_id") @db.ObjectId
  name            String
  email           String @unique
  preferenceToken String @unique @default(cuid())

  roles      Role[]
  systemRole SystemRole @default(PERSONNEL)

  college   College @relation(fields: [collegeId], references: [id])
  collegeId String  @db.ObjectId

  // A user can set many preferences
  preferences PersonnelPreference[]

  // A user can be assigned to many final scheduled events
  assignedEventIds String[]         @db.ObjectId
  assignedEvents   ScheduledEvent[] @relation("ScheduledEventPersonnel", fields: [assignedEventIds], references: [id])

  // A user can be part of the pool for many schedules
  scheduledInstanceIds String[]           @db.ObjectId
  scheduledInstances   ScheduleInstance[] @relation(fields: [scheduledInstanceIds], references: [id])

  // --- ADD THESE RELATIONS ---
  accounts Account[]
  sessions Session[]

  // Historical assignments for this user
  assignmentHistory AssignmentHistory[] @relation("PersonnelHistory")
}

model Room {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  name     String // e.g., "B510 Room 17" - removed unique constraint for multi-college
  building String
  capacity Int
  type     RoomType

  college   College @relation(fields: [collegeId], references: [id])
  collegeId String  @db.ObjectId

  // A room can host many final scheduled events
  scheduledEvents ScheduledEvent[]

  // A room can be part of the pool for many schedules
  scheduledInstanceIds String[]           @db.ObjectId
  scheduledInstances   ScheduleInstance[] @relation(fields: [scheduledInstanceIds], references: [id])

  @@unique([name, collegeId])
}

// ---------------------------------------------------
// ATTENDEE STRUCTURE - Hierarchical model for students
// ---------------------------------------------------

model Program {
  id      String  @id @default(auto()) @map("_id") @db.ObjectId
  name    String // "Computer Science - Regular" - removed unique constraint for multi-college
  batches Batch[]

  college   College @relation(fields: [collegeId], references: [id])
  collegeId String  @db.ObjectId

  @@unique([name, collegeId])
}

model Batch {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  name String // "2023 Intake"

  program   Program   @relation(fields: [programId], references: [id])
  programId String    @db.ObjectId
  sections  Section[]
}

model Section {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  name String // "Section A"

  batch   Batch   @relation(fields: [batchId], references: [id])
  batchId String  @db.ObjectId
  groups  Group[]

  // Sections that are part of a schedule instance
  scheduledInstanceIds String[]           @db.ObjectId
  scheduledInstances   ScheduleInstance[] @relation(fields: [scheduledInstanceIds], references: [id])

  // Final scheduled events for this section
  scheduledEvents ScheduledEvent[]
}

model Group {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  name String // "Group 1"

  section   Section @relation(fields: [sectionId], references: [id])
  sectionId String  @db.ObjectId

  // Final scheduled events for this group
  scheduledEvents ScheduledEvent[]
}

// ---------------------------------------------------
// ACTIVITY DEFINITION - The templates for what needs to be scheduled
// ---------------------------------------------------

model Course {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  code  String // "CS101" - removed unique constraint for multi-college
  title String // "Introduction to Programming"

  college   College @relation(fields: [collegeId], references: [id])
  collegeId String  @db.ObjectId

  // A course consists of one or more activity templates (e.g., lecture, lab)
  activityTemplates ActivityTemplate[]

  // A course can be offered in multiple schedule instances
  scheduledInstanceIds String[]           @db.ObjectId
  scheduledInstances   ScheduleInstance[] @relation(fields: [scheduledInstanceIds], references: [id])

  // Historical assignments for this course
  assignmentHistory AssignmentHistory[] @relation("CourseHistory")

  @@unique([code, collegeId])
}

model ActivityTemplate {
  id                String              @id @default(auto()) @map("_id") @db.ObjectId
  title             String // "CS101 Lecture" or "CS101 Lab"
  durationMinutes   Int
  attendeeLevel     AttendeeLevel // Is this for a SECTION or a GROUP?
  requiredPersonnel RequiredPersonnel[] // Embedded list of required roles and counts
  requiredRoomType  RoomType

  course   Course @relation(fields: [courseId], references: [id])
  courseId String @db.ObjectId

  // Preferences set by personnel for this activity
  preferences PersonnelPreference[]

  // The final scheduled events that are instances of this template
  scheduledEvents ScheduledEvent[]

  // Historical assignments for this activity template
  assignmentHistory AssignmentHistory[] @relation("ActivityHistory")
}

// ---------------------------------------------------
// SCHEDULING CONTEXT & OUTPUT
// ---------------------------------------------------

model ScheduleInstance {
  id        String         @id @default(auto()) @map("_id") @db.ObjectId
  name      String // "Fall 2025 - CS Year 1" - removed unique constraint for multi-college
  startDate DateTime
  endDate   DateTime
  status    ScheduleStatus @default(DRAFT)

  college   College @relation(fields: [collegeId], references: [id])
  collegeId String  @db.ObjectId

  // Many-to-Many relations defining the scope of this schedule
  availabilityTemplate   AvailabilityTemplate @relation(fields: [availabilityTemplateId], references: [id])
  availabilityTemplateId String               @db.ObjectId

  courseIds    String[]  @db.ObjectId
  courses      Course[]  @relation(fields: [courseIds], references: [id])
  sectionIds   String[]  @db.ObjectId
  sections     Section[] @relation(fields: [sectionIds], references: [id])
  personnelIds String[]  @db.ObjectId
  personnel    User[]    @relation(fields: [personnelIds], references: [id])
  roomIds      String[]  @db.ObjectId
  rooms        Room[]    @relation(fields: [roomIds], references: [id])

  // All preferences submitted for this schedule
  preferences PersonnelPreference[]

  // The final output: all scheduled events for this instance
  scheduledEvents ScheduledEvent[]

  // Historical records for this schedule
  assignmentHistory AssignmentHistory[] @relation("ScheduleHistory")

  // --- NEW OPTIONAL PARAMETERS FOR SOLVER ---
  roomStickinessWeight Int? // Optional weight for room stickiness, null if not set
  spacingPreference    SpacingPreference? // Optional spacing preference, null if not set
  timePreferences      ScheduleTimePreference[] // Optional time preferences, stored as a relation

  @@unique([name, collegeId])
}

model PersonnelPreference {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  rank Int

  personnel          User             @relation(fields: [personnelId], references: [id])
  personnelId        String           @db.ObjectId
  activityTemplate   ActivityTemplate @relation(fields: [activityTemplateId], references: [id])
  activityTemplateId String           @db.ObjectId
  scheduleInstance   ScheduleInstance @relation(fields: [scheduleInstanceId], references: [id])
  scheduleInstanceId String           @db.ObjectId

  // A person can only rank a specific activity once per schedule
  @@unique([personnelId, activityTemplateId, scheduleInstanceId])
}

// The final output of the allocation algorithm
model ScheduledEvent {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  dayOfWeek DayOfWeek
  startTime String // "08:30"
  endTime   String // "10:30"

  // The template this event is an instance of
  activityTemplate   ActivityTemplate @relation(fields: [activityTemplateId], references: [id])
  activityTemplateId String           @db.ObjectId

  // The resources assigned to this event
  room   Room   @relation(fields: [roomId], references: [id])
  roomId String @db.ObjectId

  personnelIds String[] @db.ObjectId
  personnel    User[]   @relation("ScheduledEventPersonnel", fields: [personnelIds], references: [id])

  // The attendees for this event (one of these will be set, not both)
  attendeeSection   Section? @relation(fields: [attendeeSectionId], references: [id])
  attendeeSectionId String?  @db.ObjectId
  attendeeGroup     Group?   @relation(fields: [attendeeGroupId], references: [id])
  attendeeGroupId   String?  @db.ObjectId

  // The schedule instance this event belongs to
  scheduleInstance   ScheduleInstance @relation(fields: [scheduleInstanceId], references: [id])
  scheduleInstanceId String           @db.ObjectId
}

// NEW MODEL for Time Preferences tied to a ScheduleInstance
model ScheduleTimePreference {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  time String // "HH:MM" format
  rank Int // A score, e.g., 10 for most preferred

  scheduleInstance   ScheduleInstance @relation(fields: [scheduleInstanceId], references: [id])
  scheduleInstanceId String           @db.ObjectId

  @@unique([scheduleInstanceId, time]) // A schedule instance has a unique rank for a specific time
}

model AssignmentHistory {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  personnel   User   @relation("PersonnelHistory", fields: [personnelId], references: [id])
  personnelId String @db.ObjectId

  course   Course @relation("CourseHistory", fields: [courseId], references: [id])
  courseId String @db.ObjectId

  activityTemplate   ActivityTemplate @relation("ActivityHistory", fields: [activityTemplateId], references: [id])
  activityTemplateId String           @db.ObjectId

  scheduleInstance   ScheduleInstance @relation("ScheduleHistory", fields: [scheduleInstanceId], references: [id])
  scheduleInstanceId String           @db.ObjectId

  college   College @relation("CollegeHistory", fields: [collegeId], references: [id])
  collegeId String  @db.ObjectId

  assignedAt  DateTime @default(now())
  performance String? // Optional performance notes

  // Composite index for efficient queries
  @@index([personnelId, courseId])
  @@index([collegeId, assignedAt])
}

// --- ADD THE FOLLOWING MODELS FOR AUTH.JS ---
model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
